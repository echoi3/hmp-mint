{"ast":null,"code":"module.exports = getBlocksForRange;\n\nasync function getBlocksForRange(_ref) {\n  let {\n    provider,\n    fromBlock,\n    toBlock\n  } = _ref;\n  if (!fromBlock) fromBlock = toBlock;\n  const fromBlockNumber = hexToInt(fromBlock);\n  const toBlockNumber = hexToInt(toBlock);\n  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1; // load all blocks from old to new (inclusive)\n\n  const missingBlockNumbers = Array(blockCountToQuery).fill().map((_, index) => fromBlockNumber + index).map(intToHex);\n  const blockBodies = await Promise.all(missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false])));\n  return blockBodies;\n}\n\nfunction hexToInt(hexString) {\n  if (hexString === undefined || hexString === null) return hexString;\n  return Number.parseInt(hexString, 16);\n}\n\nfunction incrementHexInt(hexString) {\n  if (hexString === undefined || hexString === null) return hexString;\n  const value = hexToInt(hexString);\n  return intToHex(value + 1);\n}\n\nfunction intToHex(int) {\n  if (int === undefined || int === null) return int;\n  const hexString = int.toString(16);\n  return '0x' + hexString;\n}\n\nfunction sendAsync(provider, request) {\n  return new Promise((resolve, reject) => {\n    provider.sendAsync(request, (error, response) => {\n      if (error) {\n        reject(error);\n      } else if (response.error) {\n        reject(response.error);\n      } else if (response.result) {\n        resolve(response.result);\n      } else {\n        reject(new Error(\"Result was empty\"));\n      }\n    });\n  });\n}\n\nasync function query(provider, method, params) {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await sendAsync(provider, {\n        id: 1,\n        jsonrpc: \"2.0\",\n        method,\n        params\n      });\n    } catch (error) {\n      console.error(`provider.sendAsync failed: ${error.stack || error.message || error}`);\n    }\n  }\n\n  throw new Error(`Block not found for params: ${JSON.stringify(params)}`);\n}","map":{"version":3,"sources":["/Users/echoi33/Downloads/Source V2/node_modules/@coinbase/wallet-sdk/node_modules/eth-json-rpc-filters/getBlocksForRange.js"],"names":["module","exports","getBlocksForRange","provider","fromBlock","toBlock","fromBlockNumber","hexToInt","toBlockNumber","blockCountToQuery","missingBlockNumbers","Array","fill","map","_","index","intToHex","blockBodies","Promise","all","blockNum","query","hexString","undefined","Number","parseInt","incrementHexInt","value","int","toString","sendAsync","request","resolve","reject","error","response","result","Error","method","params","i","id","jsonrpc","console","stack","message","JSON","stringify"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,iBAAjB;;AAEA,eAAeA,iBAAf,OAAmE;AAAA,MAAlC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,SAAZ;AAAuBC,IAAAA;AAAvB,GAAkC;AACjE,MAAI,CAACD,SAAL,EAAgBA,SAAS,GAAGC,OAAZ;AAEhB,QAAMC,eAAe,GAAGC,QAAQ,CAACH,SAAD,CAAhC;AACA,QAAMI,aAAa,GAAGD,QAAQ,CAACF,OAAD,CAA9B;AACA,QAAMI,iBAAiB,GAAGD,aAAa,GAAGF,eAAhB,GAAkC,CAA5D,CALiE,CAMjE;;AACA,QAAMI,mBAAmB,GAAGC,KAAK,CAACF,iBAAD,CAAL,CAAyBG,IAAzB,GACCC,GADD,CACK,CAACC,CAAD,EAAGC,KAAH,KAAaT,eAAe,GAAGS,KADpC,EAECF,GAFD,CAEKG,QAFL,CAA5B;AAGA,QAAMC,WAAW,GAAG,MAAMC,OAAO,CAACC,GAAR,CACxBT,mBAAmB,CAACG,GAApB,CAAwBO,QAAQ,IAAIC,KAAK,CAAClB,QAAD,EAAW,sBAAX,EAAmC,CAACiB,QAAD,EAAW,KAAX,CAAnC,CAAzC,CADwB,CAA1B;AAGA,SAAOH,WAAP;AACD;;AAED,SAASV,QAAT,CAAkBe,SAAlB,EAA6B;AAC3B,MAAIA,SAAS,KAAKC,SAAd,IAA2BD,SAAS,KAAK,IAA7C,EAAmD,OAAOA,SAAP;AACnD,SAAOE,MAAM,CAACC,QAAP,CAAgBH,SAAhB,EAA2B,EAA3B,CAAP;AACD;;AAED,SAASI,eAAT,CAAyBJ,SAAzB,EAAmC;AACjC,MAAIA,SAAS,KAAKC,SAAd,IAA2BD,SAAS,KAAK,IAA7C,EAAmD,OAAOA,SAAP;AACnD,QAAMK,KAAK,GAAGpB,QAAQ,CAACe,SAAD,CAAtB;AACA,SAAON,QAAQ,CAACW,KAAK,GAAG,CAAT,CAAf;AACD;;AAED,SAASX,QAAT,CAAkBY,GAAlB,EAAuB;AACrB,MAAIA,GAAG,KAAKL,SAAR,IAAqBK,GAAG,KAAK,IAAjC,EAAuC,OAAOA,GAAP;AACvC,QAAMN,SAAS,GAAGM,GAAG,CAACC,QAAJ,CAAa,EAAb,CAAlB;AACA,SAAO,OAAOP,SAAd;AACD;;AAED,SAASQ,SAAT,CAAmB3B,QAAnB,EAA6B4B,OAA7B,EAAsC;AACpC,SAAO,IAAIb,OAAJ,CAAY,CAACc,OAAD,EAAUC,MAAV,KAAqB;AACtC9B,IAAAA,QAAQ,CAAC2B,SAAT,CAAmBC,OAAnB,EAA4B,CAACG,KAAD,EAAQC,QAAR,KAAqB;AAC/C,UAAID,KAAJ,EAAW;AACTD,QAAAA,MAAM,CAACC,KAAD,CAAN;AACD,OAFD,MAEO,IAAIC,QAAQ,CAACD,KAAb,EAAoB;AACzBD,QAAAA,MAAM,CAACE,QAAQ,CAACD,KAAV,CAAN;AACD,OAFM,MAEA,IAAIC,QAAQ,CAACC,MAAb,EAAqB;AAC1BJ,QAAAA,OAAO,CAACG,QAAQ,CAACC,MAAV,CAAP;AACD,OAFM,MAEA;AACLH,QAAAA,MAAM,CAAC,IAAII,KAAJ,CAAU,kBAAV,CAAD,CAAN;AACD;AACF,KAVD;AAWD,GAZM,CAAP;AAaD;;AAED,eAAehB,KAAf,CAAqBlB,QAArB,EAA+BmC,MAA/B,EAAuCC,MAAvC,EAA+C;AAC7C,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,QAAI;AACF,aAAO,MAAMV,SAAS,CAAC3B,QAAD,EAAW;AAC/BsC,QAAAA,EAAE,EAAE,CAD2B;AAE/BC,QAAAA,OAAO,EAAE,KAFsB;AAG/BJ,QAAAA,MAH+B;AAI/BC,QAAAA;AAJ+B,OAAX,CAAtB;AAMD,KAPD,CAOE,OAAOL,KAAP,EAAc;AACdS,MAAAA,OAAO,CAACT,KAAR,CACG,8BAA6BA,KAAK,CAACU,KAAN,IAAeV,KAAK,CAACW,OAArB,IAAgCX,KAAM,EADtE;AAGD;AACF;;AACD,QAAM,IAAIG,KAAJ,CAAW,+BAA8BS,IAAI,CAACC,SAAL,CAAeR,MAAf,CAAuB,EAAhE,CAAN;AACD","sourcesContent":["module.exports = getBlocksForRange\n\nasync function getBlocksForRange({ provider, fromBlock, toBlock }) {\n  if (!fromBlock) fromBlock = toBlock\n\n  const fromBlockNumber = hexToInt(fromBlock)\n  const toBlockNumber = hexToInt(toBlock)\n  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1\n  // load all blocks from old to new (inclusive)\n  const missingBlockNumbers = Array(blockCountToQuery).fill()\n                              .map((_,index) => fromBlockNumber + index)\n                              .map(intToHex)\n  const blockBodies = await Promise.all(\n    missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false]))\n  )\n  return blockBodies\n}\n\nfunction hexToInt(hexString) {\n  if (hexString === undefined || hexString === null) return hexString\n  return Number.parseInt(hexString, 16)\n}\n\nfunction incrementHexInt(hexString){\n  if (hexString === undefined || hexString === null) return hexString\n  const value = hexToInt(hexString)\n  return intToHex(value + 1)\n}\n\nfunction intToHex(int) {\n  if (int === undefined || int === null) return int\n  const hexString = int.toString(16)\n  return '0x' + hexString\n}\n\nfunction sendAsync(provider, request) {\n  return new Promise((resolve, reject) => {\n    provider.sendAsync(request, (error, response) => {\n      if (error) {\n        reject(error);\n      } else if (response.error) {\n        reject(response.error);\n      } else if (response.result) {\n        resolve(response.result);\n      } else {\n        reject(new Error(\"Result was empty\"));\n      }\n    });\n  });\n}\n\nasync function query(provider, method, params) {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await sendAsync(provider, {\n        id: 1,\n        jsonrpc: \"2.0\",\n        method,\n        params,\n      });\n    } catch (error) {\n      console.error(\n        `provider.sendAsync failed: ${error.stack || error.message || error}`\n      );\n    }\n  }\n  throw new Error(`Block not found for params: ${JSON.stringify(params)}`);\n}\n"]},"metadata":{},"sourceType":"script"}