{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = void 0;\n\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\n\n\nasync function encrypt(plainText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n  const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n    name: \"aes-gcm\"\n  }, false, [\"encrypt\", \"decrypt\"]);\n  const enc = new TextEncoder(); // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n\n  const encryptedResult = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: ivBytes\n  }, secretKey, enc.encode(plainText));\n  const tagLength = 16;\n  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n  const authTagBytes = new Uint8Array(authTag);\n  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n  const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n  return (0, util_1.uint8ArrayToHex)(concatted);\n}\n\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n */\n\nfunction decrypt(cipherText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  return new Promise((resolve, reject) => {\n    void async function () {\n      const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n        name: \"aes-gcm\"\n      }, false, [\"encrypt\", \"decrypt\"]);\n      const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n      const ivBytes = encrypted.slice(0, 12);\n      const authTagBytes = encrypted.slice(12, 28);\n      const encryptedPlaintextBytes = encrypted.slice(28);\n      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n      const algo = {\n        name: \"AES-GCM\",\n        iv: new Uint8Array(ivBytes)\n      };\n\n      try {\n        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n        const decoder = new TextDecoder();\n        resolve(decoder.decode(decrypted));\n      } catch (err) {\n        reject(err);\n      }\n    }();\n  });\n}\n\nexports.decrypt = decrypt;","map":{"version":3,"sources":["/Users/echoi33/Downloads/Source V2/node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"],"names":["Object","defineProperty","exports","value","decrypt","encrypt","util_1","require","plainText","secret","length","Error","ivBytes","crypto","getRandomValues","Uint8Array","secretKey","subtle","importKey","hexStringToUint8Array","name","enc","TextEncoder","encryptedResult","window","iv","encode","tagLength","authTag","slice","byteLength","encryptedPlaintext","authTagBytes","encryptedPlaintextBytes","concatted","uint8ArrayToHex","cipherText","Promise","resolve","reject","encrypted","concattedBytes","algo","decrypted","decoder","TextDecoder","decode","err"],"mappings":"AAAA,a,CACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkBF,OAAO,CAACG,OAAR,GAAkB,KAAK,CAAzC;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeF,OAAf,CAAuBG,SAAvB,EAAkCC,MAAlC,EAA0C;AACtC,MAAIA,MAAM,CAACC,MAAP,KAAkB,EAAtB,EACI,MAAMC,KAAK,CAAE,yBAAF,CAAX;AACJ,QAAMC,OAAO,GAAGC,MAAM,CAACC,eAAP,CAAuB,IAAIC,UAAJ,CAAe,EAAf,CAAvB,CAAhB;AACA,QAAMC,SAAS,GAAG,MAAMH,MAAM,CAACI,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+B,CAAC,GAAGZ,MAAM,CAACa,qBAAX,EAAkCV,MAAlC,CAA/B,EAA0E;AAAEW,IAAAA,IAAI,EAAE;AAAR,GAA1E,EAA+F,KAA/F,EAAsG,CAAC,SAAD,EAAY,SAAZ,CAAtG,CAAxB;AACA,QAAMC,GAAG,GAAG,IAAIC,WAAJ,EAAZ,CALsC,CAMtC;;AACA,QAAMC,eAAe,GAAG,MAAMC,MAAM,CAACX,MAAP,CAAcI,MAAd,CAAqBZ,OAArB,CAA6B;AACvDe,IAAAA,IAAI,EAAE,SADiD;AAEvDK,IAAAA,EAAE,EAAEb;AAFmD,GAA7B,EAG3BI,SAH2B,EAGhBK,GAAG,CAACK,MAAJ,CAAWlB,SAAX,CAHgB,CAA9B;AAIA,QAAMmB,SAAS,GAAG,EAAlB;AACA,QAAMC,OAAO,GAAGL,eAAe,CAACM,KAAhB,CAAsBN,eAAe,CAACO,UAAhB,GAA6BH,SAAnD,CAAhB;AACA,QAAMI,kBAAkB,GAAGR,eAAe,CAACM,KAAhB,CAAsB,CAAtB,EAAyBN,eAAe,CAACO,UAAhB,GAA6BH,SAAtD,CAA3B;AACA,QAAMK,YAAY,GAAG,IAAIjB,UAAJ,CAAea,OAAf,CAArB;AACA,QAAMK,uBAAuB,GAAG,IAAIlB,UAAJ,CAAegB,kBAAf,CAAhC;AACA,QAAMG,SAAS,GAAG,IAAInB,UAAJ,CAAe,CAC7B,GAAGH,OAD0B,EAE7B,GAAGoB,YAF0B,EAG7B,GAAGC,uBAH0B,CAAf,CAAlB;AAKA,SAAO,CAAC,GAAG3B,MAAM,CAAC6B,eAAX,EAA4BD,SAA5B,CAAP;AACH;;AACDhC,OAAO,CAACG,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,OAAT,CAAiBgC,UAAjB,EAA6B3B,MAA7B,EAAqC;AACjC,MAAIA,MAAM,CAACC,MAAP,KAAkB,EAAtB,EACI,MAAMC,KAAK,CAAE,yBAAF,CAAX;AACJ,SAAO,IAAI0B,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,SAAM,kBAAkB;AACpB,YAAMvB,SAAS,GAAG,MAAMH,MAAM,CAACI,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+B,CAAC,GAAGZ,MAAM,CAACa,qBAAX,EAAkCV,MAAlC,CAA/B,EAA0E;AAAEW,QAAAA,IAAI,EAAE;AAAR,OAA1E,EAA+F,KAA/F,EAAsG,CAAC,SAAD,EAAY,SAAZ,CAAtG,CAAxB;AACA,YAAMoB,SAAS,GAAG,CAAC,GAAGlC,MAAM,CAACa,qBAAX,EAAkCiB,UAAlC,CAAlB;AACA,YAAMxB,OAAO,GAAG4B,SAAS,CAACX,KAAV,CAAgB,CAAhB,EAAmB,EAAnB,CAAhB;AACA,YAAMG,YAAY,GAAGQ,SAAS,CAACX,KAAV,CAAgB,EAAhB,EAAoB,EAApB,CAArB;AACA,YAAMI,uBAAuB,GAAGO,SAAS,CAACX,KAAV,CAAgB,EAAhB,CAAhC;AACA,YAAMY,cAAc,GAAG,IAAI1B,UAAJ,CAAe,CAClC,GAAGkB,uBAD+B,EAElC,GAAGD,YAF+B,CAAf,CAAvB;AAIA,YAAMU,IAAI,GAAG;AACTtB,QAAAA,IAAI,EAAE,SADG;AAETK,QAAAA,EAAE,EAAE,IAAIV,UAAJ,CAAeH,OAAf;AAFK,OAAb;;AAIA,UAAI;AACA,cAAM+B,SAAS,GAAG,MAAMnB,MAAM,CAACX,MAAP,CAAcI,MAAd,CAAqBb,OAArB,CAA6BsC,IAA7B,EAAmC1B,SAAnC,EAA8CyB,cAA9C,CAAxB;AACA,cAAMG,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACAP,QAAAA,OAAO,CAACM,OAAO,CAACE,MAAR,CAAeH,SAAf,CAAD,CAAP;AACH,OAJD,CAKA,OAAOI,GAAP,EAAY;AACRR,QAAAA,MAAM,CAACQ,GAAD,CAAN;AACH;AACJ,KAtBI,EAAL;AAuBH,GAxBM,CAAP;AAyBH;;AACD7C,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = void 0;\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\nasync function encrypt(plainText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n    const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n    const enc = new TextEncoder();\n    // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n    const encryptedResult = await window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: ivBytes,\n    }, secretKey, enc.encode(plainText));\n    const tagLength = 16;\n    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n    const authTagBytes = new Uint8Array(authTag);\n    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n    const concatted = new Uint8Array([\n        ...ivBytes,\n        ...authTagBytes,\n        ...encryptedPlaintextBytes,\n    ]);\n    return (0, util_1.uint8ArrayToHex)(concatted);\n}\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n */\nfunction decrypt(cipherText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    return new Promise((resolve, reject) => {\n        void (async function () {\n            const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n            const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n            const ivBytes = encrypted.slice(0, 12);\n            const authTagBytes = encrypted.slice(12, 28);\n            const encryptedPlaintextBytes = encrypted.slice(28);\n            const concattedBytes = new Uint8Array([\n                ...encryptedPlaintextBytes,\n                ...authTagBytes,\n            ]);\n            const algo = {\n                name: \"AES-GCM\",\n                iv: new Uint8Array(ivBytes),\n            };\n            try {\n                const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n                const decoder = new TextDecoder();\n                resolve(decoder.decode(decrypted));\n            }\n            catch (err) {\n                reject(err);\n            }\n        })();\n    });\n}\nexports.decrypt = decrypt;\n"]},"metadata":{},"sourceType":"script"}